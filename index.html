<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#0b1020" />
  <title>Mobile 360 Capture — 16 shots (South‑Locked)</title>
  <!-- Photo Sphere Viewer v5 -->
  <link rel="stylesheet" href="https://unpkg.com/photo-sphere-viewer@5/dist/photo-sphere-viewer.css"/>
  <style>
    :root{
      --bg:#0b1020; --panel:#121830; --muted:#7d8db3; --text:#e8eefc; --accent:#22c55e; --accent2:#60a5fa; --danger:#ef4444; --white:#fff;
    }
    *{box-sizing:border-box}
    html,body{height:100%;background:var(--bg);color:var(--text);font-family:System-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    body{margin:0;display:flex;flex-direction:column}

    .topbar{position:fixed;top:0;left:0;right:0;height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 12px;background:linear-gradient(180deg, rgba(0,0,0,.7), rgba(0,0,0,.25) 70%, transparent);z-index:20}
    .btn{appearance:none;border:0;border-radius:999px;padding:10px 14px;background:var(--panel);color:var(--text);font-weight:600}
    .btn:disabled{opacity:.5}
    .btn.primary{background:linear-gradient(180deg,#2dd97b,#16a34a)}
    .btn.ghost{background:transparent;border:1px solid #2a376a}

    .pill{position:absolute;left:50%;transform:translateX(-50%);top:8px;background:#1b2342;border:1px solid #2a376a;border-radius:999px;padding:8px 14px;color:#dfe7ff;font-weight:600;font-size:14px;white-space:nowrap}

    .wrap{position:relative;flex:1;display:flex;flex-direction:column}

    .video-wrap{position:relative;flex:1;overflow:hidden}
    video#cam{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}  /* mirror for stable aiming UX */
    canvas#hud{position:absolute;inset:0;pointer-events:none;width:100%;height:100%} 

    .bottom{position:fixed;bottom:0;left:0;right:0;display:flex;flex-direction:column;gap:8px;padding:10px;background:linear-gradient(0deg, rgba(0,0,0,.75), rgba(0,0,0,.25) 60%, transparent);z-index:20}
    .row{display:flex;gap:8px;align-items:center;justify-content:space-between}

    .slider{flex:1}
    input[type=range]{width:100%}

    .progress{display:flex;gap:6px;align-items:center;justify-content:center;margin-top:2px}
    .dot{width:8px;height:8px;border-radius:99px;background:#ffffff45}
    .dot.done{background:var(--accent)}
    .dot.current{background:#fff}
    .badge{margin-left:8px;background:#1b2342;border:1px solid #2a376a;border-radius:6px;padding:4px 8px;font-size:12px;color:#cfe2ff}

    .overlay-center{position:absolute;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.78);z-index:50}
    .card{background:var(--panel);border:1px solid #2a376a;border-radius:14px;padding:16px;max-width:92%;text-align:center;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .row-btns{display:flex;gap:12px;justify-content:center;flex-wrap:wrap;margin-top:12px}

    #viewerWrap{display:none;position:fixed;inset:0;background:#000;z-index:60}
    #viewer{position:absolute;inset:0}
    #viewerBar{position:absolute;top:10px;left:10px;z-index:61;display:flex;gap:8px}
    #flash{position:absolute;inset:0;background:#fff;opacity:0;pointer-events:none;transition:opacity .25s}

    .tiny{font-size:12px;color:#9fb0db}
    /* 3D overlay */
    #ar3d{position:absolute;inset:0;pointer-events:none}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <button class="btn ghost" id="btnBack">Back</button>
      <div class="pill" id="hint">Bấm Bắt đầu để cấp quyền cảm biến & camera</div>
      <button class="btn ghost" id="btnCancel">Cancel</button>
    </div>

    <div class="video-wrap" id="videoWrap">
      <video id="cam" playsinline autoplay muted></video>
      <div id="ar3d"></div>
      <canvas id="hud"></canvas>
      <div id="flash"></div>
    </div>

    <div class="bottom">
      <div class="row">
        <button class="btn" id="btnStart">Bắt đầu</button>
        <button class="btn" id="btnCalibPitch">Căn ngang (đặt 0°)</button>
        <button class="btn" id="btn3d">3D Mask: On</button>
        <button class="btn primary" id="btnShot" disabled>Chụp</button>
      </div>
      <div class="row slider">
        <label class="tiny" for="fov">vFOV: <span id="fovVal">60</span>°</label>
        <input id="fov" type="range" min="40" max="80" value="60" step="1" />
        <button class="btn" id="btnStitch" disabled>Ghép ảnh</button>
      </div>
      <div class="progress" id="progress"></div>
    </div>
  </div>

  <!-- Viewer Layer -->
  <div id="viewerWrap">
    <div id="viewerBar">
      <button class="btn" id="btnCloseViewer">Close</button>
      <a class="btn primary" id="btnDownload" download="panorama-360.jpg" href="#">Tải JPG</a>
    </div>
    <div id="viewer"></div>
  </div>

  <!-- Libraries -->
  <script src="https://docs.opencv.org/4.x/opencv.js" async></script>
  <script src="https://unpkg.com/uevent@2/browser.min.js"></script>
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://unpkg.com/photo-sphere-viewer@5/dist/photo-sphere-viewer.js"></script>

  <script>
  // ================== Spec constants ==================
  const targets = [
    // 8 equator
    {yaw:0,pitch:0},{yaw:45,pitch:0},{yaw:90,pitch:0},{yaw:135,pitch:0},
    {yaw:180,pitch:0},{yaw:225,pitch:0},{yaw:270,pitch:0},{yaw:315,pitch:0},
    // 4 top
    {yaw:0,pitch:-30},{yaw:90,pitch:-30},{yaw:180,pitch:-30},{yaw:270,pitch:-30},
    // 4 bottom
    {yaw:0,pitch:30},{yaw:90,pitch:30},{yaw:180,pitch:30},{yaw:270,pitch:30},
  ];
  const YAW_TOL=5, PITCH_TOL=5, ROLL_TOL=3;

  // ================== Elements ==================
  const el = (id)=>document.getElementById(id);
  const video = el('cam');
  const hud = el('hud');
  const ctx = hud.getContext('2d');
  const hint = el('hint');
  const progress = el('progress');
  const flash = el('flash');

  const btnStart = el('btnStart');
  const btnCalibPitch = el('btnCalibPitch');
  const btnShot = el('btnShot');
  const btnStitch = el('btnStitch');
  const btnBack = el('btnBack');
  const btnCancel = el('btnCancel');

  const btn3d = el('btn3d');
  const ar3dContainer = document.getElementById('ar3d');

  const fovSlider = el('fov');
  const fovVal = el('fovVal');

  const viewerWrap = el('viewerWrap');
  const viewerDiv = el('viewer');
  const btnCloseViewer = el('btnCloseViewer');
  const btnDownload = el('btnDownload');

  // ================== State ==================
  let started=false, stream=null;
  let haveMotion=false, haveOrientation=false;

  // Raw sensors
  let rawAlpha=0; // compass heading (0=N)
  let accX=0, accY=0, accZ=0;

  // Logical angles
  let compassOffset=0; // to lock South as 0°
  let compassCalibrated=false;
  let yaw=0, pitch=0, roll=0;
  let pitchZero=0; // user-defined horizontal zero

  let idx=0; // current target index
  let captured=[]; // {yaw,pitch,dataUrl}

  let vFOVdeg = 60; // adjustable

  // 3D overlay state
  let threeEnabled = true;
  let three = null; // {renderer, scene, camera, ring, rectGreen, rectWhite, arrow, group, container}

  // OpenCV gate
  let cvReady = new Promise(res=>{
    const check=()=>{ if(window.cv && cv.Mat) res(true); else setTimeout(check,200); };
    check();
  });

  // ================== Utils ==================
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const toRad=(d)=>d*Math.PI/180;
  const toDeg=(r)=>r*180/Math.PI;
  function diffAngle(a,b){
    let d = ((a-b+540)%360)-180; // [-180,180)
    return Math.abs(d);
  }
  function wrap360(a){ a%=360; if(a<0)a+=360; return a; }
  function lowpassAngle(prev, next, t){
    // interpolate shortest way around circle
    let d = ((next - prev + 540) % 360) - 180;
    return wrap360(prev + d * t);
  }

  // Build progress dots
  function renderProgress(){
    progress.innerHTML='';
    for(let i=0;i<targets.length;i++){
      const d=document.createElement('div');
      d.className='dot'+(i<idx?' done':'')+(i===idx?' current':'');
      progress.appendChild(d);
    }
    const badge=document.createElement('span');
    badge.className='badge';
    badge.textContent=`${Math.min(idx,16)}/16`;
    progress.appendChild(badge);
  }

  function nextYawForStep(i){
    const cur = targets[i%targets.length];
    const nxt = targets[(i+1)%targets.length];
    return nxt.yaw;
  }

  function maskForStep(currentYaw, nextYaw, targetPitch){
    if (targetPitch === 0){
      const dir = (((nextYaw - currentYaw + 540)%360)-180) >= 0 ? 'right':'left';
      return {type:'circle-arrow', dir};
    }
    if (targetPitch < 0) return {type:'rect-green'};
    return {type:'rect-white'};
  }

  function guidanceText(errYaw, errPitch, errRoll){
    if (Math.abs(errRoll) > ROLL_TOL){
      return errRoll>0? 'Tilt your device to the left' : 'Tilt your device to the right';
    }
    if (Math.abs(errYaw) > YAW_TOL){
      return errYaw>0? 'Rotate right to align' : 'Rotate left to align';
    }
    if (Math.abs(errPitch) > PITCH_TOL){
      return errPitch>0? 'Tilt down slightly' : 'Raise the device slightly';
    }
    return 'Hold still and tap Capture';
  }

  // ================== Camera ==================
  async function startCamera(){
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal:'environment' },
          width: { ideal: 1920 }, height: { ideal: 1080 }
        }, audio:false
      });
      video.srcObject = stream;
      await video.play();
      resizeHUD();
    }catch(err){
      console.error(err);
      hint.textContent = 'Không mở được camera. Hãy dùng HTTPS và cho phép camera.';
    }
  }

  function stopCamera(){
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  }

  function resizeHUD(){
    const dpr = window.devicePixelRatio || 1;
    hud.width = hud.clientWidth * dpr;
    hud.height = hud.clientHeight * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeHUD);

  // ================== Sensors ==================
  async function requestSensorPermissions(){
    try{
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
        await DeviceOrientationEvent.requestPermission();
      }
    }catch(e){/* ignore */}
    try{
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
        await DeviceMotionEvent.requestPermission();
      }
    }catch(e){/* ignore */}
  }

  function onOrientation(e){
    haveOrientation=true;
    let alpha = (typeof e.webkitCompassHeading === 'number')
      ? (360 - e.webkitCompassHeading) // iOS returns clockwise from North; invert to match alpha
      : (typeof e.alpha === 'number' ? e.alpha : 0);
    rawAlpha = wrap360(alpha);

    if(started && !compassCalibrated){
      const headingStart = rawAlpha;
      compassOffset = wrap360(180 - headingStart); // South -> 0° logic
      compassCalibrated = true;
    }

    const logical = wrap360(rawAlpha + compassOffset);
    yaw = compassCalibrated ? lowpassAngle(yaw, logical, 0.25) : logical;
  }

  function rotateAxesPortrait(ax,ay,az){
    // Normalize to portrait (0°). If device is rotated, swap axes.
    const ang = (screen.orientation && typeof screen.orientation.angle==='number') ? screen.orientation.angle : 0;
    switch(ang){
      case 90: return {x:ay, y:-ax, z:az};
      case 270: return {x:-ay, y:ax, z:az};
      case 180: return {x:-ax, y:-ay, z:az};
      default: return {x:ax, y:ay, z:az};
    }
  }

  function onMotion(e){
    haveMotion=true;
    const a = e.accelerationIncludingGravity || e.acceleration || {x:0,y:0,z:-9.8};
    ({x:accX,y:accY,z:accZ} = rotateAxesPortrait(a.x||0,a.y||0,a.z||0));

    // Pitch/roll from gravity
    let p = toDeg(Math.atan2(-accX, Math.hypot(accY, accZ)));
    let r = toDeg(Math.atan2( accY, accZ));

    // User horizontal zero adjustment
    p = p - pitchZero;

    // Smooth
    pitch = lerp(pitch, p, 0.25);
    roll  = lerp(roll,  r, 0.25);
  }

  // ================== HUD Drawing ==================
  function drawHUD(){
    if(!hud.width) return;
    ctx.clearRect(0,0,hud.width,hud.height);

    const dpr = window.devicePixelRatio || 1; const w = hud.width / dpr, h = hud.height / dpr;

    // Target + errors
    const t = targets[Math.min(idx, targets.length-1)];
    const errYaw = (((t?.yaw ?? 0) - yaw + 540)%360) - 180; // signed [-180,180)
    const errPitch = (t?.pitch ?? 0) - pitch;
    const errRoll = -roll; // positive = tilt left, for text sense

    // Mask
    const nextYaw = nextYawForStep(idx);
    const mask = maskForStep(yaw, nextYaw, t.pitch);

    const pxPerDeg = h / vFOVdeg; // portrait mapping
    const yOffset = - (t.pitch) * pxPerDeg; // negative pitch -> move up

    // Central reticle
    const cx = w/2, cy = h/2 + yOffset;

    // Draw masks (2D)
    ctx.save();
    if(mask.type==='circle-arrow'){
      ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.beginPath();
      const R = Math.min(w,h)*0.35;
      ctx.arc(cx, cy, R, 0, Math.PI*2);
      ctx.stroke();

      // Arrow left/right at side
      const arrowX = cx + (mask.dir==='right'? R+28 : -R-28);
      const arrowY = cy;
      drawArrow(arrowX, arrowY, mask.dir==='right'? 0 : Math.PI, 28);
    }
    else if(mask.type==='rect-green' || mask.type==='rect-white'){
      const rw = Math.min(w*0.86, 420);
      const rh = Math.min(h*0.46, 360);
      const rx = (w-rw)/2, ry = (h-rh)/2 + yOffset;
      // panel
      ctx.save();
      ctx.fillStyle = (mask.type==='rect-green')? 'rgba(16,185,129,.35)' : 'rgba(255,255,255,.28)';
      roundRect(ctx, rx, ry, rw, rh, 22);
      ctx.fill();
      // circular hole at center using destination-out
      ctx.globalCompositeOperation='destination-out';
      ctx.beginPath(); ctx.arc(cx, cy, Math.min(rw,rh)*0.28, 0, Math.PI*2); ctx.fill();
      ctx.globalCompositeOperation='source-over';

      if(mask.type==='rect-green'){
        // White arrow up inside the hole
        drawArrow(cx, cy, -Math.PI/2, 28);
        // White circle at bottom of rect
        ctx.beginPath(); ctx.arc(cx, ry+rh-22, 10, 0, Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
      }
      ctx.restore();
    }
    ctx.restore();

    // Reticle (always visible)
    ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2);
    ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();

    // Guidance pill
    const text = guidanceText(errYaw, errPitch, errRoll);
    hint.textContent = text;

    // Kick 3D overlay update
    if(threeEnabled && three){ render3DMask(errYaw, errPitch); }

    requestAnimationFrame(drawHUD);
  }

  function drawTiny(s,x,y){ ctx.fillStyle='#9fb0db'; ctx.font='12px system-ui'; ctx.fillText(s,x,y); }
  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }
  function drawArrow(x,y,angle,len){
    ctx.save();
    ctx.translate(x,y); ctx.rotate(angle);
    ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(-len*0.6, 0); ctx.lineTo(len*0.6, 0); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(len*0.2, -len*0.35); ctx.lineTo(len*0.6, 0); ctx.lineTo(len*0.2, len*0.35); ctx.stroke();
    ctx.restore();
  }

  // ================== 3D Overlay (Three.js) ==================
  function initThree(){
    if(!ar3dContainer) return;
    const r = new THREE.WebGLRenderer({alpha:true, antialias:true});
    r.setPixelRatio(window.devicePixelRatio||1);
    r.setSize(ar3dContainer.clientWidth, ar3dContainer.clientHeight, false);
    ar3dContainer.innerHTML='';
    ar3dContainer.appendChild(r.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(vFOVdeg, ar3dContainer.clientWidth/ar3dContainer.clientHeight, 0.1, 100);
    scene.add(new THREE.AmbientLight(0xffffff, 1));

    const group = new THREE.Group();
    scene.add(group);

    // Circle ring for equator
    const ring = new THREE.Mesh(
      new THREE.RingGeometry(0.25, 0.3, 64),
      new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.95, side:THREE.DoubleSide})
    );
    ring.visible=false; group.add(ring);

    // Rect w/ hole textures
    function roundRect2D(g, x,y,w,h,r){
      const rr=Math.min(r,w/2,h/2); g.beginPath(); g.moveTo(x+rr,y);
      g.arcTo(x+w,y,x+w,y+h,rr); g.arcTo(x+w,y+h,x,y+h,rr); g.arcTo(x,y+h,x,y,rr); g.arcTo(x,y,x+w,y,rr); g.closePath();
    }
    function makeRectTex(color){
      const s=256, c=document.createElement('canvas'); c.width=c.height=s; const g=c.getContext('2d');
      g.clearRect(0,0,s,s);
      g.fillStyle=color; g.globalAlpha=0.35; roundRect2D(g, 18, 40, s-36, s-80, 28); g.fill(); g.globalAlpha=1;
      g.globalCompositeOperation='destination-out'; g.beginPath(); g.arc(s/2, s/2, 58, 0, Math.PI*2); g.fill(); g.globalCompositeOperation='source-over';
      return new THREE.CanvasTexture(c);
    }
    const rectGreenTex = makeRectTex('#10b981');
    const rectWhiteTex = makeRectTex('#ffffff');

    const planeGeo = new THREE.PlaneGeometry(0.9, 0.7);
    const rectGreen = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({map:rectGreenTex, transparent:true, side:THREE.DoubleSide}));
    rectGreen.visible=false; group.add(rectGreen);

    const rectWhite = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({map:rectWhiteTex, transparent:true, side:THREE.DoubleSide}));
    rectWhite.visible=false; group.add(rectWhite);

    // 3D arrow (left/right indicator)
    const arrow = new THREE.Group();
    const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.01,0.01,0.3,12), new THREE.MeshBasicMaterial({color:0xffffff}));
    shaft.position.y=0.15; arrow.add(shaft);
    const tip = new THREE.Mesh(new THREE.ConeGeometry(0.05,0.1,16), new THREE.MeshBasicMaterial({color:0xffffff}));
    tip.position.y=0.31; arrow.add(tip);
    arrow.visible=false; group.add(arrow);

    three = {renderer:r, scene, camera, ring, rectGreen, rectWhite, arrow, group, container:ar3dContainer};
  }

  function resizeThree(){
    if(!three) return;
    const w = three.container.clientWidth, h = three.container.clientHeight;
    three.renderer.setSize(w,h,false);
    three.camera.aspect = w/h; three.camera.fov=vFOVdeg; three.camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resizeThree);

  function render3DMask(errYaw, errPitch){
    if(!three || !threeEnabled) return;
    const t = targets[Math.min(idx, targets.length-1)];

    // Position a mask at a fixed distance along camera forward, offset by delta yaw/pitch
    const d = 1.5; // meters (relative)
    const ox = Math.tan(toRad(errYaw)) * d;
    const oy = Math.tan(toRad(-errPitch)) * d;
    const oz = -d;

    // Hide all first
    three.ring.visible=false; three.rectGreen.visible=false; three.rectWhite.visible=false; three.arrow.visible=false;

    if(t.pitch===0){
      three.ring.visible=true;
      three.ring.position.set(ox, oy, oz);
      three.ring.lookAt(three.camera.position);
      // Arrow side
      const side = ((((nextYawForStep(idx) - yaw + 540)%360)-180) >= 0) ? 1 : -1;
      three.arrow.visible=true;
      three.arrow.position.set(ox + side*0.6, oy, oz);
      three.arrow.lookAt(ox, oy, oz);
    } else if(t.pitch<0){
      three.rectGreen.visible=true;
      three.rectGreen.position.set(ox, oy, oz);
      three.rectGreen.lookAt(three.camera.position);
    } else {
      three.rectWhite.visible=true;
      three.rectWhite.position.set(ox, oy, oz);
      three.rectWhite.lookAt(three.camera.position);
    }

    three.renderer.render(three.scene, three.camera);
  }

  // ================== Capture & Sequence ==================
  function updateShotButton(){
    const t = targets[Math.min(idx, targets.length-1)];
    const yawOk   = diffAngle(yaw, t.yaw) <= YAW_TOL;
    const pitchOk = Math.abs(pitch - t.pitch) <= PITCH_TOL;
    const rollOk  = Math.abs(roll) <= ROLL_TOL;
    btnShot.disabled = !(yawOk && pitchOk && rollOk && started);
  }

  async function doShot(){
    if(!video.videoWidth) return;
    flash.style.opacity=0.9; setTimeout(()=>flash.style.opacity=0, 80);
    const c = document.createElement('canvas');
    const w = video.videoWidth, h = video.videoHeight;
    c.width=w; c.height=h;
    const cctx = c.getContext('2d');
    // Draw as-is (no mirror)
    cctx.drawImage(video,0,0,w,h);
    const dataUrl = c.toDataURL('image/jpeg', 0.92);

    const t = targets[idx];
    captured.push({ yaw:t.yaw, pitch:t.pitch, dataUrl, w, h, vFOV:vFOVdeg });
    idx = Math.min(idx+1, targets.length);
    renderProgress();
    if(idx>=targets.length){ btnStitch.disabled=false; btnShot.disabled=true; hint.textContent='Đã chụp đủ 16/16 — Bấm “Ghép ảnh”'; }
  }

  // ================== Stitch (Client only) ==================
  // Implementation note: this compositor maps each shot into an approximate equirectangular mosaic
  // using known yaw/pitch and UI vFOV. It blends overlaps with soft masks. If OpenCV.js is available,
  // a lightweight Gaussian blur is applied to the alpha mask for feathering. This avoids heavy feature
  // matching on mobile while satisfying the client-only constraint.

  async function stitchPanorama(shots){
    if(!shots.length) throw new Error('No shots');
    const panoW = 4096, panoH = 2048; // 2:1 equirectangular

    // Base canvas
    const pano = document.createElement('canvas');
    pano.width=panoW; pano.height=panoH;
    const pctx = pano.getContext('2d');
    pctx.fillStyle='#000'; pctx.fillRect(0,0,panoW,panoH);

    // Draw each shot based on yaw/pitch and FOV
    const imgCache = await Promise.all(shots.map(s=>loadImage(s.dataUrl)));

    // Compute aspect & hFOV from the first image and vFOV setting stored with that shot
    const aspect = shots[0].w / shots[0].h;

    for(let i=0;i<shots.length;i++){
      const s = shots[i];
      const img = imgCache[i];
      const vF = s.vFOV || vFOVdeg;
      const hF = toDeg( 2*Math.atan(Math.tan(toRad(vF/2)) * (s.w/s.h)) );

      const destW = panoW * (hF/360);
      const destH = panoH * (vF/180);

      // Left-top of patch in the equirect grid
      let x = ((s.yaw - hF/2 + 360)%360) / 360 * panoW;
      const y = (panoH/2) - destH/2 - (s.pitch/180)*panoH;

      // Build a soft alpha gradient mask
      const mask = document.createElement('canvas');
      mask.width = Math.ceil(destW); mask.height = Math.ceil(destH);
      const mctx = mask.getContext('2d');
      const gradX = mctx.createLinearGradient(0,0,mask.width,0);
      gradX.addColorStop(0,'rgba(255,255,255,0)');
      gradX.addColorStop(0.15,'rgba(255,255,255,1)');
      gradX.addColorStop(0.85,'rgba(255,255,255,1)');
      gradX.addColorStop(1,'rgba(255,255,255,0)');
      mctx.fillStyle=gradX; mctx.fillRect(0,0,mask.width,mask.height);

      // Paste image into a temp canvas properly scaled
      const patch = document.createElement('canvas');
      patch.width = Math.ceil(destW); patch.height = Math.ceil(destH);
      const p2 = patch.getContext('2d');
      p2.drawImage(img, 0,0, s.w, s.h, 0,0, patch.width, patch.height);

      // Optionally blur the mask edges with OpenCV if available
      try{
        await cvReady;
        const src = cv.imread(mask);
        const dst = new cv.Mat();
        const k = new cv.Size(21,21);
        cv.GaussianBlur(src, dst, k, 0, 0, cv.BORDER_DEFAULT);
        cv.imshow(mask, dst);
        src.delete(); dst.delete();
      }catch(e){/* cv not ready, skip */}

      // Composite with mask using drawImage + globalCompositeOperation
      // Handle wrap-around at x near right edge by drawing twice
      function compositeAt(X){
        // write patch
        pctx.save();
        // write mask into alpha
        pctx.globalCompositeOperation='destination-out';
        pctx.drawImage(mask, X, y);
        pctx.globalCompositeOperation='destination-over';
        pctx.drawImage(patch, X, y);
        pctx.restore();
      }
      compositeAt(x);
      if(x + destW > panoW){ // wrap to left
        compositeAt(x - panoW);
      }
    }

    // Export JPEG dataURL
    return pano.toDataURL('image/jpeg', 0.92);
  }

  function loadImage(url){
    return new Promise((res,rej)=>{ const im=new Image(); im.onload=()=>res(im); im.onerror=rej; im.src=url; });
  }

  // ================== Viewer ==================
  let psv=null;
  function showViewer(panoramaUrl){
    viewerWrap.style.display='block';
    if(psv){ try{ psv.destroy(); }catch(e){} psv=null; }
    psv = new PhotoSphereViewer.Viewer({
      container: viewerDiv,
      panorama: panoramaUrl,
      navbar: ['zoom','autorotate','fullscreen'],
      defaultYaw: 0,
      touchmoveTwoFingers: true
    });
  }

  // ================== Orchestration ==================
  async function startAll(){
    try{ await screen.orientation?.lock?.('portrait'); }catch(e){}
    await requestSensorPermissions();

    window.addEventListener('deviceorientation', onOrientation, true);
    window.addEventListener('devicemotion', onMotion, true);

    started=true; compassCalibrated=false; idx=0; captured.length=0; renderProgress();
    hint.textContent='Đang mở camera & căn hướng Nam... giữ máy ổn định';
    await startCamera();
    resizeHUD();
    if(threeEnabled){ initThree(); resizeThree(); }
    drawHUD();
  }

  function resetAll(){
    started=false; compassCalibrated=false; idx=0; captured.length=0; renderProgress();
    stopCamera();
    hint.textContent='Bấm Bắt đầu để cấp quyền cảm biến & camera';
    btnStitch.disabled=true; btnShot.disabled=true;
    if(three){ three.renderer.dispose(); ar3dContainer.innerHTML=''; three=null; }
  }

  // ================== Events ==================
  btnStart.addEventListener('click', startAll);
  btnCalibPitch.addEventListener('click', ()=>{ pitchZero = pitchZero + (pitch); });
  btnShot.addEventListener('click', doShot);
  btnStitch.addEventListener('click', async()=>{
    btnStitch.disabled=true; hint.textContent='Đang ghép ảnh 360...';
    try{
      const panoUrl = await stitchPanorama(captured);
      btnDownload.href = panoUrl;
      showViewer(panoUrl);
      hint.textContent='Hoàn tất ghép ảnh';
    }catch(e){ console.error(e); hint.textContent='Ghép ảnh thất bại: '+e.message; btnStitch.disabled=false; }
  });
  btnBack.addEventListener('click', resetAll);
  btnCancel.addEventListener('click', resetAll);

  fovSlider.addEventListener('input', e=>{ vFOVdeg = +e.target.value; fovVal.textContent=vFOVdeg; resizeHUD(); resizeThree(); });


  // Update shot button enablement tied to HUD loop
  setInterval(()=>{ if(started) updateShotButton(); }, 80);

  // Viewer controls
  btnCloseViewer.addEventListener('click', ()=>{ viewerWrap.style.display='none'; });

  // 3D toggle
  btn3d.addEventListener('click', ()=>{
    threeEnabled = !threeEnabled;
    btn3d.textContent = '3D Mask: ' + (threeEnabled ? 'On' : 'Off');
    ar3dContainer.style.display = threeEnabled ? 'block' : 'none';
    if(threeEnabled && !three){ initThree(); resizeThree(); }
  });

  // Initialize('click', ()=>{ viewerWrap.style.display='none'; });

  // Initialize
  renderProgress();

  // UX tip for insecure origins
  if(location.protocol!=='https:' && !location.href.startsWith('file:')){
    hint.textContent='Khuyến nghị chạy qua HTTPS (hoặc file:// trên Android) để mở camera';
  }
  </script>
</body>
</html>
