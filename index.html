<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Mobile 360 Capture — 16 ảnh (South-Locked + Framing Mask)</title>

<!-- Viewer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photo-sphere-viewer@5/dist/photo-sphere-viewer.min.css">
<script src="https://cdn.jsdelivr.net/npm/uevent@2/browser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photo-sphere-viewer@5/dist/photo-sphere-viewer.min.js"></script>

<!-- OpenCV.js (WASM) -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<style>
  :root { --panel-bg: rgba(0,0,0,.55); --ok:#18ff4a; --warn:#ffba08; --arrow:#00c8ff; }
  html,body{ margin:0; height:100%; background:#000; font-family:system-ui,Arial,sans-serif; }
  video#cam{ position:fixed; inset:0; width:100%; height:100%; object-fit:cover; transform:scaleX(-1); }
  canvas#hud{ position:fixed; inset:0; width:100%; height:100%; pointer-events:none; }
  #panel{
    position:fixed; left:0; right:0; bottom:0; padding:10px 8px; color:#fff;
    background:var(--panel-bg); backdrop-filter:blur(6px); font-size:14px; text-align:center;
  }
  #panel .row{ margin-top:6px; display:flex; flex-wrap:wrap; align-items:center; justify-content:center; gap:6px; }
  #panel button{ padding:9px 14px; margin:2px; font-size:15px; border:0; border-radius:10px; }
  #panel button:disabled{ opacity:.5 }
  #viewer{ display:none; position:fixed; inset:0; z-index:10; background:#000; }
  .hint{ position:fixed; top:8px; left:8px; right:8px; color:#fff; font-size:12px;
         background:var(--panel-bg); padding:6px 8px; border-radius:10px; }
  @media (orientation:landscape){
    .hint::after{ content:"Vui lòng xoay dọc (portrait) để chụp chính xác."; display:block; margin-top:4px; color:#ffef8a; }
  }
  label.inline{ display:inline-flex; align-items:center; gap:6px; background:rgba(255,255,255,.12); padding:6px 8px; border-radius:10px; }
  input[type=range]{ width:120px; }
</style>
</head>
<body>

<div class="hint">
  Bấm <b>Bắt đầu</b> → (tùy chọn) <b>Căn ngang</b> để đặt 0° → căn HUD (thanh ngang thẳng, la bàn & pitch xanh),
  đưa <b>hồng tâm</b> vào <b>khung đích</b> → <b>Chụp</b> 16 ảnh theo mũi tên → <b>Ghép ảnh</b> → Xem 360 → Tải ảnh.
</div>

<video id="cam" playsinline autoplay></video>
<canvas id="hud"></canvas>

<div id="panel">
  <div>Yaw: <b id="yawVal">0</b>° | Pitch: <b id="pitchVal">0</b>° | Roll: <b id="rollVal">0</b>°</div>
  <div>Target: yaw <b id="yawT">0</b>° | pitch <b id="pitchT">0</b>° &nbsp; (South-locked)</div>
  <div class="row">
    <button id="startBtn">Bắt đầu</button>
    <button id="calibPitchBtn">Căn ngang (đặt 0°)</button>
    <label class="inline">vFOV:
      <input id="vfov" type="range" min="40" max="80" value="60" step="1" />
      <span id="vfovVal">60°</span>
    </label>
    <button id="shotBtn" disabled>Chụp</button>
    <button id="stitchBtn" disabled>Ghép ảnh</button>
    <button id="viewBtn" disabled>Xem 360</button>
    <button id="downloadBtn" disabled>Tải ảnh</button>
    <button id="resetBtn">Reset</button>
  </div>
</div>

<div id="viewer"></div>

<script>
/* ====================== CONFIG / TARGETS (16 shots) ====================== */
const targets = [
  // Equator (8)
  {yaw:0,pitch:0},{yaw:45,pitch:0},{yaw:90,pitch:0},{yaw:135,pitch:0},
  {yaw:180,pitch:0},{yaw:225,pitch:0},{yaw:270,pitch:0},{yaw:315,pitch:0},
  // Top (4)
  {yaw:0,pitch:-30},{yaw:90,pitch:-30},{yaw:180,pitch:-30},{yaw:270,pitch:-30},
  // Bottom (4)
  {yaw:0,pitch:30},{yaw:90,pitch:30},{yaw:180,pitch:30},{yaw:270,pitch:30},
];
const YAW_TOL=5, PITCH_TOL=5, ROLL_TOL=3;

/* ====================== STATE ====================== */
let idx=0, captured=[], compassOffset=0, compassCalibrated=false, panoUrl=null, viewer=null;
let pitchZero = 0;                 // offset “đặt 0°” theo tư thế người dùng
let lastPose = { yaw:0, pitch:0, roll:0 };
let V_FOV_DEG = 60;                // góc nhìn dọc ước lượng, để quy đổi pitch→pixel mask

/* ====================== DOM ====================== */
const cam=document.getElementById('cam');
const hud=document.getElementById('hud'); const ctx=hud.getContext('2d');
const yawEl=document.getElementById('yawVal'), pitchEl=document.getElementById('pitchVal'), rollEl=document.getElementById('rollVal');
const yawT=document.getElementById('yawT'), pitchT=document.getElementById('pitchT');
const startBtn=document.getElementById('startBtn'), shotBtn=document.getElementById('shotBtn'), stitchBtn=document.getElementById('stitchBtn');
const viewBtn=document.getElementById('viewBtn'), downloadBtn=document.getElementById('downloadBtn'), viewerDiv=document.getElementById('viewer');
const calibPitchBtn=document.getElementById('calibPitchBtn');
const vfov=document.getElementById('vfov'), vfovVal=document.getElementById('vfovVal');

vfov.oninput=()=>{ V_FOV_DEG=+vfov.value; vfovVal.textContent=V_FOV_DEG+'°'; };
calibPitchBtn.onclick=()=>{ pitchZero = lastPose.pitch; };

/* ====================== INIT ====================== */
startBtn.onclick = startApp;
shotBtn.onclick = onCapture;
stitchBtn.onclick = doStitch;
viewBtn.onclick = () => { viewerDiv.style.display='block'; initViewer(); };
downloadBtn.onclick = downloadPano;
document.getElementById('resetBtn').onclick = resetAll;

function resetAll(){
  idx=0; captured=[]; panoUrl=null;
  viewBtn.disabled=true; downloadBtn.disabled=true; stitchBtn.disabled=true;
  shotBtn.disabled=true; yawT.textContent=targets[0].yaw; pitchT.textContent=targets[0].pitch;
}

async function startApp(){
  await initCamera();
  await initOrientation(); // DeviceOrientation + DeviceMotion
  lockPortrait();
  yawT.textContent=targets[0].yaw; pitchT.textContent=targets[0].pitch;
}

async function initCamera(){
  const s = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false });
  cam.srcObject=s; await cam.play();
}

async function initOrientation(){
  // iOS cần xin quyền cho cả Orientation & Motion
  if (window.DeviceOrientationEvent?.requestPermission) {
    try{ await DeviceOrientationEvent.requestPermission(); }catch{}
  }
  if (window.DeviceMotionEvent?.requestPermission) {
    try{ await DeviceMotionEvent.requestPermission(); }catch{}
  }
  // YAW từ alpha (để khóa hướng Nam)
  window.addEventListener('deviceorientation',(e)=>{
    if (e.alpha==null) return;
    if (!compassCalibrated) calibrateToSouth(e.alpha);
    const yaw = (e.alpha + compassOffset + 360) % 360; // 0° logic = Nam
    lastPose.yaw = yaw;
  },true);

  // PITCH/ROLL từ vector gravity (ổn định theo mặt đất)
  window.addEventListener('devicemotion',(e)=>{
    if (!e.accelerationIncludingGravity) return;
    const { pitchDeg, rollDeg } = poseFromGravity(e.accelerationIncludingGravity);
    lastPose.pitch = pitchDeg - pitchZero;  // căn ngang làm 0°
    lastPose.roll  = rollDeg;

    updateHUD(lastPose.yaw, lastPose.pitch, lastPose.roll);
  },true);
}

function calibrateToSouth(alphaMagNorth){
  // đặt South (180° thật) -> 0° logic
  const headingStart=alphaMagNorth;
  compassOffset = (180 - headingStart + 360) % 360;
  compassCalibrated=true;
}

function lockPortrait(){
  if (screen.orientation?.lock) screen.orientation.lock('portrait').catch(()=>{});
}

/* ---- Tính pitch/roll từ gravity, quy về portrait ---- */
function poseFromGravity(g){
  // Trục portrait: x→ phải, y→ lên, z→ ra khỏi màn
  let gx=g.x, gy=g.y, gz=g.z;

  // Bù xoay màn hình để quy về portrait
  const ang = (screen.orientation?.angle ?? window.orientation ?? 0);
  const rad = ang * Math.PI/180;
  const cos = Math.cos(-rad), sin = Math.sin(-rad);
  const rx = gx*cos - gy*sin;
  const ry = gx*sin + gy*cos;
  const rz = gz;

  // pitch = atan2(-rx, sqrt(ry^2 + rz^2)), roll = atan2(ry, rz)
  const pitch = Math.atan2(-rx, Math.hypot(ry, rz));
  const roll  = Math.atan2( ry, rz );

  return { pitchDeg: pitch*180/Math.PI, rollDeg: roll*180/Math.PI };
}

/* ====================== HUD DRAW ====================== */
function diffAngle(a,b){ let d=Math.abs(a-b)%360; return d>180?360-d:d; }

function updateHUD(yaw,pitch,roll){
  yawEl.textContent=yaw.toFixed(0); pitchEl.textContent=pitch.toFixed(0); rollEl.textContent=roll.toFixed(0);

  const t=targets[idx]; yawT.textContent=t.yaw; pitchT.textContent=t.pitch;
  const yawOk  = diffAngle(yaw,t.yaw)<=YAW_TOL;
  const pitchOk= Math.abs(pitch-t.pitch)<=PITCH_TOL;
  const rollOk = Math.abs(roll)<=ROLL_TOL;
  shotBtn.disabled = !(yawOk&&pitchOk&&rollOk);

  drawHUD(yaw,pitch,roll);
}

function drawHUD(yaw,pitch,roll){
  const w=hud.width=innerWidth, h=hud.height=innerHeight;
  ctx.clearRect(0,0,w,h);
  const cx=w/2, cy=h/2, r=Math.min(w,h)*0.18;

  // frame
  ctx.lineWidth=6; ctx.strokeStyle='#000';
  ctx.strokeRect(w*0.08,h*0.04,w*0.84,h*0.92);

  // center circle
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();

  // roll level
  ctx.save();
  ctx.translate(cx,cy); ctx.rotate(roll*Math.PI/180);
  ctx.strokeStyle = Math.abs(roll)<=ROLL_TOL ? '#18ff4a' : '#ffba08';
  ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(-r*0.8,0); ctx.lineTo(r*0.8,0); ctx.stroke();
  ctx.restore();

  // yaw compass ring
  const t=targets[idx]; const yawErr=diffAngle(yaw,t.yaw);
  ctx.save();
  ctx.translate(cx,cy); ctx.rotate((yaw-90)*Math.PI/180);
  ctx.strokeStyle = yawErr<=YAW_TOL ? '#18ff4a' : '#ffba08';
  ctx.lineWidth=6; ctx.beginPath();
  ctx.arc(0,0,r*1.45,-Math.PI/12,Math.PI/12); ctx.stroke();
  ctx.restore();

  // pitch bar (right)
  const barX=w*0.92, barY=h*0.15, barH=h*0.7, barW=6;
  ctx.strokeStyle='#bbb'; ctx.strokeRect(barX-barW/2,barY,barW,barH);
  const pitchOK = Math.abs(pitch-t.pitch)<=PITCH_TOL;
  const yPos = barY + barH * ((-pitch + 90)/180); // hiển thị tương đối
  ctx.beginPath(); ctx.lineWidth=4; ctx.strokeStyle = pitchOK ? '#18ff4a' : '#ffba08';
  ctx.moveTo(barX-15, yPos); ctx.lineTo(barX+15, yPos); ctx.stroke();

  // === MASK KHUNG ĐÍCH THEO TARGET PITCH + HỒNG TÂM ===
  drawFramingMask(t.pitch, V_FOV_DEG);
  drawCrosshair(cx, cy, r);

  // next arrow
  if (idx<targets.length-1) drawNextArrow(yaw,targets[idx+1].yaw,cx,cy,r);
}

function drawCrosshair(cx, cy, r){
  ctx.lineWidth = 2; ctx.strokeStyle = '#ffffff';
  // vòng tròn nhỏ
  ctx.beginPath(); ctx.arc(cx, cy, r*0.25, 0, Math.PI*2); ctx.stroke();
  // dấu cộng
  ctx.beginPath();
  ctx.moveTo(cx - r*0.35, cy); ctx.lineTo(cx + r*0.35, cy);
  ctx.moveTo(cx, cy - r*0.35); ctx.lineTo(cx, cy + r*0.35);
  ctx.stroke();
}

function drawFramingMask(targetPitchDeg, vFovDeg){
  const w = hud.width, h = hud.height;
  const cx = w/2, cy = h/2;

  // Quy đổi pitch đích -> offset pixel theo vFOV
  const pxPerDeg = h / vFovDeg;        // xấp xỉ, tinh chỉnh bằng thanh vFOV
  const yOffset = - targetPitchDeg * pxPerDeg;  // ngẩng (âm) -> dịch lên

  const winW = w * 0.55;   // kích thước khung đích
  const winH = h * 0.32;
  const rx = cx - winW/2;
  const ry = cy + yOffset - winH/2;

  // lớp phủ tối mờ
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(0,0,w,h);

  // "đục" cửa sổ (destination-out)
  ctx.globalCompositeOperation = 'destination-out';
  roundRect(ctx, rx, ry, winW, winH, 14);
  ctx.fill();

  // viền sáng cho cửa sổ
  ctx.globalCompositeOperation = 'source-over';
  ctx.lineWidth = 3;
  ctx.strokeStyle = '#00ffd0';
  roundRect(ctx, rx, ry, winW, winH, 14);
  ctx.stroke();
  ctx.restore();

  // gợi ý
  ctx.fillStyle = '#ffffff';
  ctx.font = '600 12px system-ui, Arial';
  ctx.textAlign = 'center';
  ctx.fillText('Đưa hồng tâm vào trong khung đích rồi chụp', cx, ry - 10);
}

function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function drawNextArrow(currentYaw,nextYaw,cx,cy,radius){
  const delta = (nextYaw - currentYaw + 540)%360 - 180; // -180..180 (đường ngắn nhất)
  const a = (delta)*Math.PI/180;
  const r1 = radius*1.3, r2=radius*1.7;
  const ax=cx + r1*Math.cos(a - Math.PI/2), ay=cy + r1*Math.sin(a - Math.PI/2);
  const bx=cx + r2*Math.cos(a - Math.PI/2), by=cy + r2*Math.sin(a - Math.PI/2);
  ctx.strokeStyle=getArrowColor(delta); ctx.lineWidth=4;
  ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
  const head=15;
  ctx.beginPath(); ctx.moveTo(bx,by);
  ctx.lineTo(bx - head*Math.cos(a - Math.PI/2 - Math.PI/6), by - head*Math.sin(a - Math.PI/2 - Math.PI/6));
  ctx.lineTo(bx - head*Math.cos(a - Math.PI/2 + Math.PI/6), by - head*Math.sin(a - Math.PI/2 + Math.PI/2 - Math.PI/3));
  ctx.closePath(); ctx.fillStyle=getArrowColor(delta); ctx.fill();
}
function getArrowColor(delta){
  const ad=Math.abs(delta);
  if (ad<60) return '#00c8ff';
  if (ad<120) return '#22a6f2';
  return '#2e86de';
}

/* ====================== CAPTURE ====================== */
function onCapture(){
  const c=document.createElement('canvas'); c.width=cam.videoWidth; c.height=cam.videoHeight;
  c.getContext('2d').drawImage(cam,0,0);
  const dataUrl=c.toDataURL('image/jpeg',0.92);
  captured.push({ yaw:targets[idx].yaw, pitch:targets[idx].pitch, dataUrl });
  idx++;
  if (idx>=targets.length){ shotBtn.disabled=true; stitchBtn.disabled=false; }
}

/* ====================== STITCH (OpenCV.js) ====================== */
async function doStitch(){
  stitchBtn.disabled=true;
  panoUrl = await stitchSequence(captured);
  viewBtn.disabled=false; downloadBtn.disabled=false;
}

// Helpers
function dataURLToMat(dataUrl,maxW=1800){
  return new Promise(res=>{
    const img=new Image();
    img.onload=()=>{
      const scale=Math.min(1,maxW/img.width);
      const w=Math.round(img.width*scale), h=Math.round(img.height*scale);
      const c=document.createElement('canvas'); c.width=w; c.height=h;
      c.getContext('2d').drawImage(img,0,0,w,h);
      const id=c.getContext('2d').getImageData(0,0,w,h);
      res(cv.matFromImageData(id));
    };
    img.src=dataUrl;
  });
}

function matToDataURL(mat, q=0.92){
  const c=document.createElement('canvas'); c.width=mat.cols; c.height=mat.rows;
  const imgData=new ImageData(new Uint8ClampedArray(mat.data), mat.cols, mat.rows);
  c.getContext('2d').putImageData(imgData,0,0);
  return c.toDataURL('image/jpeg', q);
}

function toGray(m){ const g=new cv.Mat(); cv.cvtColor(m,g,cv.COLOR_RGBA2GRAY); return g; }

function matchAndHomography(A,B){
  const gA=toGray(A), gB=toGray(B);
  const orb=new cv.ORB(); const kpA=new cv.KeyPointVector(), kpB=new cv.KeyPointVector();
  const desA=new cv.Mat(), desB=new cv.Mat();
  orb.detectAndCompute(gA,new cv.Mat(),kpA,desA);
  orb.detectAndCompute(gB,new cv.Mat(),kpB,desB);
  const bf=new cv.BFMatcher(cv.NORM_HAMMING,true); const mv=new cv.DMatchVector();
  bf.match(desA,desB,mv);
  const arr=[]; for(let i=0;i<mv.size();i++) arr.push(mv.get(i));
  arr.sort((a,b)=>a.distance-b.distance);
  const keep=arr.slice(0,Math.max(15,Math.floor(arr.length*0.5)));
  const src=[], dst=[];
  keep.forEach(m=>{ const p1=kpA.get(m.queryIdx).pt, p2=kpB.get(m.trainIdx).pt; src.push(p1.x,p1.y); dst.push(p2.x,p2.y); });
  const srcM=cv.matFromArray(keep.length,1,cv.CV_32FC2,new Float32Array(src));
  const dstM=cv.matFromArray(keep.length,1,cv.CV_32FC2,new Float32Array(dst));
  const H=cv.findHomography(dstM, srcM, cv.RANSAC, 4.0);
  // cleanup
  gA.delete(); gB.delete(); orb.delete(); kpA.delete(); kpB.delete(); desA.delete(); desB.delete(); bf.delete(); mv.delete(); srcM.delete(); dstM.delete();
  return H;
}

function blendLinear(base,overlay){
  const gray=new cv.Mat(); cv.cvtColor(overlay,gray,cv.COLOR_RGBA2GRAY);
  const mask=new cv.Mat(); cv.threshold(gray,mask,1,255,cv.THRESH_BINARY);
  const feather=new cv.Mat(); cv.GaussianBlur(mask,feather,new cv.Size(21,21),0);
  const inv=new cv.Mat(); cv.bitwise_not(feather,inv);
  cv.cvtColor(feather,feather,cv.COLOR_GRAY2RGBA); cv.cvtColor(inv,inv,cv.COLOR_GRAY2RGBA);
  const roi=base.roi(new cv.Rect(0,0,overlay.cols,overlay.rows));
  const tmp1=new cv.Mat(), tmp2=new cv.Mat();
  cv.multiply(overlay,feather,tmp1,1/255); cv.multiply(roi,inv,tmp2,1/255); cv.add(tmp1,tmp2,roi);
  tmp1.delete(); tmp2.delete(); roi.delete(); inv.delete(); feather.delete(); mask.delete(); gray.delete();
  return base;
}

function autoCrop(mat){
  const gray=new cv.Mat(); cv.cvtColor(mat,gray,cv.COLOR_RGBA2GRAY);
  const mask=new cv.Mat(); cv.threshold(gray,mask,1,255,cv.THRESH_BINARY);
  const cnts=new cv.MatVector(), hier=new cv.Mat(); cv.findContours(mask,cnts,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
  let rect=new cv.Rect(0,0,mat.cols,mat.rows);
  if (cnts.size()>0){
    let x=1e9, y=1e9, r=0, b=0;
    for(let i=0;i<cnts.size();i++){ const rr=cv.boundingRect(cnts.get(i)); x=Math.min(x,rr.x); y=Math.min(y,rr.y); r=Math.max(r,rr.x+rr.width); b=Math.max(b,rr.y+rr.height); }
    rect=new cv.Rect(x,y,Math.max(1,r-x),Math.max(1,b-y));
  }
  const out=mat.roi(rect).clone(); gray.delete(); mask.delete(); cnts.delete(); hier.delete(); return out;
}

async function stitchSequence(datas){
  const imgs=[];
  for (const d of datas){ const m=await dataURLToMat(d.dataUrl, 1800); imgs.push({yaw:d.yaw, mat:m}); }
  imgs.sort((a,b)=>a.yaw-b.yaw);

  let pano=imgs[0].mat.clone();
  for (let i=1;i<imgs.length;i++){
    const A=pano, B=imgs[i].mat;
    const H=matchAndHomography(A,B);
    const warped=new cv.Mat();
    const size=new cv.Size(A.cols + Math.round(B.cols*0.9), Math.max(A.rows,B.rows));
    cv.warpPerspective(B,warped,H,size,cv.INTER_LINEAR,cv.BORDER_TRANSPARENT,new cv.Scalar());
    const canvas=new cv.Mat.zeros(size.height,size.width,A.type());
    const roi=canvas.roi(new cv.Rect(0,0,A.cols,A.rows)); A.copyTo(roi); roi.delete();
    const blended=blendLinear(canvas,warped);
    pano.delete(); canvas.delete(); warped.delete(); H.delete();
    pano=blended;
  }
  const cropped=autoCrop(pano); pano.delete();
  const url=matToDataURL(cropped,0.92); cropped.delete();
  return url;
}

/* ====================== VIEWER / DOWNLOAD ====================== */
function initViewer(){
  if (viewer) viewer.destroy();
  viewer = new PhotoSphereViewer.Viewer({
    container: viewerDiv, panorama: panoUrl,
    defaultYaw: 0, navbar: ['zoom','autorotate','fullscreen'], touchmoveTwoFingers: true
  });
  // chạm để thoát viewer
  viewerDiv.addEventListener('click', ()=>{ viewerDiv.style.display='none'; viewer.destroy(); viewer=null; }, { once:true });
}

function downloadPano(){
  const a=document.createElement('a');
  a.href=panoUrl; a.download='panorama-360.jpg'; a.click();
}
</script>
</body>
</html>
